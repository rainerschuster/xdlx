/*
 * Copyright 2007 Rainer Schuster
 * 
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.rainerschuster.dlx;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.NoSuchElementException;

/**
 * This class contains the data structure for the DLX-algorithm.
 */
public class DancingLinksData<C, V extends Value<C>> implements Iterable<Column<C, V>> {

    /** Root column. */
    private Column<C, V> root;

    private List<Column<C, V>> columns;

    // private List<Column<C, V>> secondaryColumns;
    private Column<C, V> lastColumn;

    /**
     * The primary columns generated by the
     * {@link com.rainerschuster.dlx.DataGenerator}.
     */
    private List<C> generatedPrimaryColumns;

    /**
     * The secondary columns generated by the
     * {@link com.rainerschuster.dlx.DataGenerator}.
     */
    private List<C> generatedSecondaryColumns;

    /**
     * The values generated by the {@link com.rainerschuster.dlx.DataGenerator}.
     */
    private List<V> generatedValues;

    public DancingLinksData() {
        super();
        columns = new ArrayList<Column<C, V>>();
        // secondaryColumns = new ArrayList<Column<C, V>>();
        root = new Column<C, V>();
        lastColumn = root;
    }

    public Column<C, V> getRoot() {
        return this.root;
    }

    public void setRoot(final Column<C, V> root) {
        this.root = root;
    }

    public void addPrimaryColumn(final C columnValue) {
        addXColumn(columnValue, true);
        finalizePrimaryColumns();
    }

    public void addSecondaryColumn(final C columnValue) {
        addXColumn(columnValue, false);
    }

    public void addAllPrimaryColumns(final List<C> columnValues) {
        for (C columnValue : columnValues) {
            addXColumn(columnValue, true);
        }
        finalizePrimaryColumns();
    }

    public void addAllSecondaryColumns(final List<C> columnValues) {
        // TODO secondaryColumns.addAll(columnValues);
        if (columnValues != null) {
            for (C columnValue : columnValues) {
                addXColumn(columnValue, false);
            }
        }
    }

    private void addXColumn(final C columnValue, final boolean primary) {
        final Column<C, V> column = new Column<C, V>();
        column.setValue(columnValue);
        column.setHead(new Node<C, V>());
        // column.getHead().up = column.getHead().down = column.getHead();
        column.getHead().setUp(column.getHead());
        column.getHead().setDown(column.getHead());
        // column.getHead().column = column;
        column.getHead().setColumn(column);
        column.setLength(0);

        if (primary) {
            lastColumn.setNext(column);
            column.setPrev(lastColumn);
            lastColumn = column;
        } else {
            // column.prev = column.next = column;
            column.setPrev(column);
            column.setNext(column);
            // secondaryColumns.add(column);
        }

        columns.add(column);
    }

    public void finalizePrimaryColumns() {
        root.setPrev(lastColumn);
        lastColumn.setNext(root);
    }

    public void addRowContinuous(final V value) {
        Node<C, V> rowStart = null;
        Node<C, V> lastNode = null;
        for (Column<C, V> column : value.inRelations(columns)) {
            final Node<C, V> myNode = new Node<C, V>();
            if (rowStart == null) {
                rowStart = myNode;
                lastNode = myNode;
            } else {
                myNode.setLeft(lastNode);
                lastNode.setRight(myNode);
            }

            myNode.setColor(value.relationColor(column.getValue()));
            myNode.setColumn(column);
            myNode.setValue(value);

            myNode.setUp(column.getHead().getUp());

            column.getHead().getUp().setDown(myNode);
            column.getHead().setUp(myNode);
            myNode.setDown(column.getHead());
            // column.length++;
            column.setLength(column.getLength() + 1);
            lastNode = myNode;
        }
        rowStart.setLeft(lastNode);
        lastNode.setRight(rowStart);
    }

    /**
     * @param columnValue
     *            the value of the column
     * @return the column with the specified name or <code>null</code> if it
     *         can't be found
     */
    public Column<C, V> getColumn(final C columnValue) {
        // TODO QUEST search in non-active columns too?
        for (Column<C, V> column : columns) {
            if (column != null && columnValue.equals(column.getValue())) {
                return column;
            }
        }
        System.err.println("Error in getColumn: Column \"" + columnValue
                + "\" not found");
        return null;
    }

    // 6
    /**
     * A row is identified not by name but by the values of the columns it
     * contains. Here is a routine that prints a row, given a pointer to any of
     * its nodes. It also prints the position of the given node in its column.
     */
    public static <C, V extends Value<C>> void printRow(final Node<C, V> p) {
        Node<C, V> q = p;
        int k;
        do {
            System.out.print(" " + q.getColumn().getValue());
            if (q.getColor() != 0) {
                // print the color of node q
                System.out.print(":" + ((q.getColor() > 0) ? q.getColor() : q.getColumn().getHead().getColor()));
            }
            q = q.getRight();
        } while (q != p);
        for (q = p.getColumn().getHead().getDown(), k = 1; q != p; k++) {
            if (q == p.getColumn().getHead()) {
                // row not in its column!
                System.out.println();
                return;
            } else {
                q = q.getDown();
            }
        }
        System.out.println(" (" + k + " of " + p.getColumn().getLength() + ")");
    }

    protected class PrimaryColumnIterator implements Iterator<Column<C, V>> {
        private Column<C, V> column = root;

        private boolean justRemoved = false;

        @Override
        public boolean hasNext() {
            return column != null && column.getNext() != root;
        }

        @Override
        public Column<C, V> next() {
            if (!hasNext()) {
                throw new NoSuchElementException();
            }

            justRemoved = false;

            column = column.getNext();

            return column;
        }

        @Override
        public void remove() {
            if (column == null || column == root || justRemoved) {
                throw new IllegalStateException();
            }

            column.getPrev().setNext(column.getNext());
            column.getNext().setPrev(column.getPrev());

            justRemoved = true;
        }
    }

    @Override
    public Iterator<Column<C, V>> iterator() {
        return new PrimaryColumnIterator();
    }

    /**
     * @return All columns whether they are covered or not!
     */
    public List<Column<C, V>> getAllColumns() {
        return columns;
    }

    /*public List<Column<C, V>> getSecondaryColumns() {
        return secondaryColumns;
    }*/

    public void resetMarks() {
        for (Column<C, V> column : this) {
            for (Node<C, V> row : column) {
                for (Node<C, V> node : row) {
                    node.setMarked(false);
                }
            }
        }
    }

    public List<C> getGeneratedPrimaryColumns() {
        return generatedPrimaryColumns;
    }

    public void setGeneratedPrimaryColumns(List<C> generatedPrimaryColumns) {
        this.generatedPrimaryColumns = generatedPrimaryColumns;
    }

    public List<C> getGeneratedSecondaryColumns() {
        return generatedSecondaryColumns;
    }

    public void setGeneratedSecondaryColumns(List<C> generatedSecondaryColumns) {
        this.generatedSecondaryColumns = generatedSecondaryColumns;
    }

    public List<V> getGeneratedValues() {
        return generatedValues;
    }

    public void setGeneratedValues(List<V> generatedValues) {
        this.generatedValues = generatedValues;
    }

}
